#include <QSize>
#include <QString>
#include <QStringView>
#include <QMessageBox>
#include <QFontDialog>
#include <QFileDialog>
#include <QColorDialog>
#include <QInputDialog>
#include <QWhatsThis>
#include <QKeySequence>
#include <QShortcut>
#include <QSvgGenerator>

#include "sorting_network_maker.h"
#include "generators.h"

using namespace sorting_network;

SortingNetworkMaker::SortingNetworkMaker(QWidget *parent) \
    : QMainWindow(parent), lines(Qt::black), background(Qt::white), \
    exampleFont(this->font()), resolution(64), equalElements(1), \
    generated(false), saved(false) {
    this->ui.setupUi(this);
    connect(this->ui.actionQt, SIGNAL(triggered()), qApp, SLOT(aboutQt()));
    connect(this->ui.actionSave, SIGNAL(triggered()), this, SLOT(save()));
    connect(this->ui.buttonSave, SIGNAL(clicked()), this, SLOT(save()));
    connect(this->ui.buttonGenerate, SIGNAL(clicked()), this, SLOT(generate()));
    connect(this->ui.actionGenerate, SIGNAL(triggered()), this, SLOT(generate()));

#ifndef QT_NO_WHATSTHIS
    // QWhatsThis::enterWhatsThisMode is not a slot
    connect(this->ui.actionWhatsThis, &QAction::triggered, &QWhatsThis::enterWhatsThisMode);
#endif

#ifndef QT_NO_SHORTCUT
    // For keyboards with numpad, 'Enter' and 'Return' are different keys
    new QShortcut(QKeySequence(Qt::Key_Return), this, SLOT(generate()));
    new QShortcut(QKeySequence(Qt::Key_Up), this->ui.selectSize, SLOT(stepUp()));
    new QShortcut(QKeySequence(Qt::Key_Down), this->ui.selectSize, SLOT(stepDown()));
    new QShortcut(QKeySequence(Qt::Key_PageUp), this, SLOT(previousAlgorithm()));
    new QShortcut(QKeySequence(Qt::Key_PageDown), this, SLOT(nextAlgorithm()));
#endif
}

void SortingNetworkMaker::save() {
    QString defaultFileName(tr("untitled")), fileFormat;
    defaultFileName.append(CSTR(".png"));
    fileFormat.append(tr("Pixel Image")).append(CSTR(" (*.png *.jpg *.bmp *.ppm *.xbm *.xpm);;"));
    fileFormat.append(tr("Scalable Vector Graphics")).append(CSTR(" (*.svg);;"));
    fileFormat.append(tr("QT Painter Command Sequence")).append(CSTR(" (*.pic)"));

    auto filename = QFileDialog::getSaveFileName(
        this, tr("Save figure"), defaultFileName, fileFormat
    );
    if (!filename.isNull()) {
        bool ok;
        if(filename.endsWith(CSTR(".svg"))) {
            QSvgGenerator svg;
            svg.setFileName(filename);
            svg.setTitle(QSTR("Sorting Network"));
            svg.setDescription(QSTR("Generated by Sorting Network Maker. Saved as SVG with QT"));
            ok = show_picture(this->picture, &svg);
        } else if(filename.endsWith(CSTR(".pic"))) {
            ok = this->picture.save(filename);
        } else {
            ok = this->pixmap.save(filename, nullptr, 95);
        }
        if(ok) {
            this->saved = true;
        } else {
            this->errorMessage(tr("Failed to save figure as \"%1\"").arg(filename));
        }
    }
}

void SortingNetworkMaker::on_actionLineColor_triggered() {
    auto color = QColorDialog::getColor(this->lines, this, tr("Select line color"));
    if (color.isValid()) {
        this->lines = color;
    }
}

void SortingNetworkMaker::on_actionBackgroundColor_triggered() {
    auto color = QColorDialog::getColor(this->background, this, tr("Select background color"));
    if (color.isValid()) {
        int alpha = this->background.alpha();
        this->background = color;
        this->background.setAlpha(alpha);
    }
}

void SortingNetworkMaker::on_actionBackgroundTransparency_triggered() {
    bool ok;
    auto alpha = QInputDialog::getInt(this, tr("Set transparency"), tr("alpha"), 
        this->background.alpha(), 0, 255, 1, &ok);
    if (ok) {
        this->background.setAlpha(alpha);
    }
}

void SortingNetworkMaker::on_actionResolution_triggered() {
    bool ok;
    auto resolution = QInputDialog::getInt(this, tr("Set resolution"), tr("pixels"), 
        this->resolution, 2, 256, 1, &ok);
    if (ok) {
        this->resolution = resolution;
    }
}


void SortingNetworkMaker::on_actionExampleFont_triggered() {
    bool ok;
    auto font = QFontDialog::getFont(&ok, this->exampleFont, this);
    if (ok) {
        this->exampleFont = font;
    }
}

void SortingNetworkMaker::on_actionTestStability_triggered() {
    bool ok;
    auto eq = QInputDialog::getInt(this, tr("Test sorting stability"), tr("number of equal elements"), 
        this->equalElements, 1, 8, 1, &ok);
    if (ok) {
        this->equalElements = eq;
    }
}

void SortingNetworkMaker::refresh() {
    auto size = this->ui.scrollArea->size() - QSize(50,50);
    auto keepAspectRatio = this->ui.actionKeepAspectRatio->isChecked();
    auto aspectRatio = keepAspectRatio ? Qt::KeepAspectRatioByExpanding : Qt::IgnoreAspectRatio;
    this->ui.scrollArea->setHorizontalScrollBarPolicy(keepAspectRatio ? Qt::ScrollBarAlwaysOn : Qt::ScrollBarAsNeeded);
    this->ui.showPicture->resize(size);
    this->ui.showPicture->setPixmap(this->pixmap.scaled(size, aspectRatio, Qt::SmoothTransformation));
}

void SortingNetworkMaker::generate() {
    auto w = this->resolution;
    auto h = this->resolution;
    auto equal = this->equalElements;
    auto n = this->ui.selectSize->value();
    auto index = this->ui.selectAlgorithm->currentIndex();
    auto reproducible = this->ui.actionTestReproducible->isChecked();
    auto showExample = this->ui.actionShowTestExample->isChecked();
    Layout::Options flags;
    flags.setFlag(Layout::SplitParallel,  this->ui.actionSplitParallel->isChecked());
    flags.setFlag(Layout::SplitRecursive, this->ui.actionSplitRecursive->isChecked());
    flags.setFlag(Layout::Compact,        this->ui.actionCompact->isChecked());
    TestedPainter builder(n, equal, reproducible);
    algorithm::generate_network(index, n, &builder);
    builder.layout(flags);
    this->ui.opValueLabel->setNum(builder.getNumberOfComparator());
    this->ui.latencyValueLabel->setNum(builder.getLatency());
    this->ui.actionSave->setEnabled(true);
    this->ui.buttonSave->setEnabled(true);
    this->saved = false;
    this->generated = true;
    if(showExample) {
        this->picture = builder.paint(w, h, this->lines, this->background, this->exampleFont);
    } else {
        this->picture = builder.paint(w, h, this->lines, this->background);
    }
    this->pixmap = picture_to_pixmap(this->picture);
    this->refresh();
    if(!builder.checkSorted()) {
        QString msg = ((equal > 1) ? tr("This network fails the stability test.") \
            : tr("This network fails the correctness test."));
        this->errorMessage(msg);
    }
}

bool SortingNetworkMaker::askSaveOrContinue() {
    if (this->generated && ! this->saved)  {
        auto button = QMessageBox::question(
            this, 
            tr("Quit"), 
            tr("Save figure?"),
            QMessageBox::Save | QMessageBox::No | QMessageBox::Cancel
        );
        if (button == QMessageBox::No) {
            return true;
        }
        else if (button == QMessageBox::Save) {
            this->save();
            return true;
        }
        else {
            return false;
        }
    }
    else {
        return true;
    }
}

void SortingNetworkMaker::closeEvent(QCloseEvent *event) {
    if (this->askSaveOrContinue()) {
        event->accept();
    }
    else {
        event->ignore();
    }
}

void SortingNetworkMaker::on_selectAlgorithm_currentIndexChanged(int index) {
    auto m = algorithm::maximum_n(index);
    if(m != this->ui.selectSize->maximum()) {
        this->ui.selectSize->setMaximum(m);
    }
}

void SortingNetworkMaker::previousAlgorithm() {
    auto idx = this->ui.selectAlgorithm->currentIndex() - 1;
    if(idx >= 0) {
        this->ui.selectAlgorithm->setCurrentIndex(idx);
    }
}

void SortingNetworkMaker::nextAlgorithm() {
    auto idx = this->ui.selectAlgorithm->currentIndex() + 1;
    if(idx < this->ui.selectAlgorithm->count()) {
        this->ui.selectAlgorithm->setCurrentIndex(idx);
    }
}

void SortingNetworkMaker::errorMessage(const QString &msg){
    QMessageBox::warning(this, tr("Error"), msg);
}

void SortingNetworkMaker::on_actionAbout_triggered() {
    QLatin1String p("<p>"), q("</p>");
    QLatin1String ref_author("<a href='https://github.com/NIC0NIC0NI'>NIC0NIC0NI</a>");
    QLatin1String ref_license("<a href='http://doc.qt.io/qt-5/lgpl.html'>GNU LGPL version 3</a>");
    QLatin1String ref_code("<a href='https://github.com/NIC0NIC0NI/QT-gui-toys.git'>QT-gui-toys.git</a>");
    QString text;
    text.append(p).append((tr("This is an opensource software."))).append(q);
    text.append(p).append(tr("Author: ")).append(ref_author).append(q);
    text.append(p).append(tr("License: ")).append(ref_license).append(q);
    text.append(p).append(tr("View source code: ")).append(ref_code).append(q);
    QMessageBox::about(this, tr("About Sorting Network Maker"), text);
}
