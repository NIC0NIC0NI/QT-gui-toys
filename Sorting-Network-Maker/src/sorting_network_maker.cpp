#include <cstddef>
#include <QSize>
#include <QString>
#include <QStringView>
#include <QMessageBox>
#include <QFontDialog>
#include <QFileDialog>
#include <QColorDialog>
#include <QInputDialog>
#include <QWhatsThis>
#include <QKeySequence>
#include <QShortcut>
#include <QSvgGenerator>

#include "sorting_network_maker.h"
#include "generators.h"

using namespace sorting_network;

SortingNetworkMaker::SortingNetworkMaker(QWidget *parent) \
    : QMainWindow(parent), lines(Qt::black), background(Qt::white), \
    exampleFont(this->font()), resolution(64), equalElements(1), \
    generated(false), saved(false) {
    this->ui.setupUi(this);
    connect(this->ui.actionQt, SIGNAL(triggered()), qApp, SLOT(aboutQt()));
    connect(this->ui.actionAbout, SIGNAL(triggered()), this, SLOT(about()));
    connect(this->ui.actionSave, SIGNAL(triggered()), this, SLOT(save()));
    connect(this->ui.buttonSave, SIGNAL(clicked()), this, SLOT(save()));
    connect(this->ui.buttonGenerate, SIGNAL(clicked()), this, SLOT(generate()));
    connect(this->ui.actionLineColor, SIGNAL(triggered()), this, SLOT(selectLineColor()));
    connect(this->ui.actionBackgroundColor, SIGNAL(triggered()), this, SLOT(selectBackgroundColor()));
    connect(this->ui.actionBackgroundTransparency, SIGNAL(triggered()), this, SLOT(selectBackgroundTransparency()));
    connect(this->ui.actionResolution, SIGNAL(triggered()), this, SLOT(selectResolution()));
    connect(this->ui.actionExampleFont, SIGNAL(triggered()), this, SLOT(selectExampleFont()));
    connect(this->ui.actionTestStability, SIGNAL(triggered()), this, SLOT(selectStabilityTestType()));
    connect(this->ui.selectAlgorithm, SIGNAL(currentIndexChanged(int)), this, SLOT(adjustInputRange(int)));
    connect(this->ui.actionWhatsThis, SIGNAL(triggered()), this, SLOT(whatsThis()));

#ifndef QT_NO_SHORTCUT
    // QPushButton "generate" can only set one shortcut
    // For keyboards with numpad, 'Enter' and 'Return' are different keys
    new QShortcut(QKeySequence("Return"), this, SLOT(generate()));
    new QShortcut(QKeySequence("Enter"), this, SLOT(generate()));
#endif
}

void SortingNetworkMaker::whatsThis() {
    QWhatsThis::enterWhatsThisMode();
}

void SortingNetworkMaker::save() {
    QString defaultFileName(tr("untitled")), fileFormat;
    defaultFileName.append(".png");
    fileFormat.append(tr("Portable Network Graphics")).append(" (*.png);;");
    fileFormat.append(tr("Joint Photographic Experts Group")).append(" (*.jpg);;");
    fileFormat.append(tr("Portable Pixmap")).append(" (*.ppm);;");
    fileFormat.append(tr("Windows Bitmap")).append(" (*.bmp);;");
    fileFormat.append(tr("X11 Bitmap")).append(" (*.xbm);;");
    fileFormat.append(tr("X11 Pixmap")).append(" (*.xpm);;");
    fileFormat.append(tr("Scalable Vector Graphics")).append(" (*.svg);;");
    fileFormat.append(tr("QT Painter Command Sequence")).append(" (*.pic)");

    auto filename = QFileDialog::getSaveFileName(
        this, tr("Save figure"), defaultFileName, fileFormat
    );
    if (!filename.isNull()) {
        bool ok;
        if(filename.endsWith(QString(".svg"))) {
            QSvgGenerator svg;
            svg.setFileName(filename);
            svg.setTitle(QString("Sorting Network"));
            svg.setDescription(QString("Generated by Sorting Network Maker. Saved as SVG with QT"));
            ok = show_picture(this->picture, &svg);
        } else if(filename.endsWith(QString(".pic"))) {
            ok = this->picture.save(filename);
        } else {
            ok = this->pixmap.save(filename, nullptr, 95);
        }
        if(ok) {
            this->saved = true;
        }
    }
}

void SortingNetworkMaker::adjustInputRange(int index) {
    auto m = algorithm::maximum_n(index);
    if(m != this->ui.selectSize->maximum()) {
        this->ui.selectSize->setMaximum(m);
    }
}

void SortingNetworkMaker::selectLineColor() {
    auto color = QColorDialog::getColor(this->lines, this, tr("Select line color"));
    if (color.isValid()) {
        this->lines = color;
    }
}

void SortingNetworkMaker::selectBackgroundColor() {
    auto color = QColorDialog::getColor(this->background, this, tr("Select background color"));
    if (color.isValid()) {
        int alpha = this->background.alpha();
        this->background = color;
        this->background.setAlpha(alpha);
    }
}

void SortingNetworkMaker::selectBackgroundTransparency() {
    bool ok;
    auto alpha = QInputDialog::getInt(this, tr("Set transparency"), tr("alpha"), 
        this->background.alpha(), 0, 255, 1, &ok);
    if (ok) {
        this->background.setAlpha(alpha);
    }
}

void SortingNetworkMaker::selectResolution() {
    bool ok;
    auto resolution = QInputDialog::getInt(this, tr("Select resolution"), tr("scale"), 
        this->resolution, 2, 256, 1, &ok);
    if (ok) {
        this->resolution = resolution;
    }
}


void SortingNetworkMaker::selectExampleFont() {
    bool ok;
    auto font = QFontDialog::getFont(&ok, this->exampleFont, this);
    if (ok) {
        this->exampleFont = font;
    }
}

void SortingNetworkMaker::selectStabilityTestType() {
    bool ok;
    auto eq = QInputDialog::getInt(this, tr("Test sorting stability"), tr("number of equal elements"), 
        this->equalElements, 1, 8, 1, &ok);
    if (ok) {
        this->equalElements = eq;
    }
}

void SortingNetworkMaker::refresh() {
    auto size = this->ui.scrollArea->size() - QSize(50,50);
    auto keepAspectRatio = this->ui.actionKeepAspectRatio->isChecked();
    auto aspectRatio = keepAspectRatio ? Qt::KeepAspectRatioByExpanding : Qt::IgnoreAspectRatio;
    this->ui.scrollArea->setHorizontalScrollBarPolicy(keepAspectRatio ? Qt::ScrollBarAlwaysOn : Qt::ScrollBarAsNeeded);
    this->ui.showPicture->resize(size);
    this->ui.showPicture->setPixmap(this->pixmap.scaled(size, aspectRatio, Qt::SmoothTransformation));
}

void SortingNetworkMaker::generate() {
    auto n = this->ui.selectSize->value();
    auto index = this->ui.selectAlgorithm->currentIndex();
    auto split_levels = this->ui.actionSplitLevels->isChecked();
    auto compact = this->ui.actionCompact->isChecked();
    auto reproducible = this->ui.actionTestReproducible->isChecked();
    auto showExample = this->ui.actionShowTestExample->isChecked();
    auto w = this->resolution;
    auto h = this->resolution;
    int equal = this->equalElements;
    TestedPainter builder(n, equal, reproducible);
    algorithm::generate_network(index, n, &builder);
    builder.layout(split_levels, compact);
    this->ui.opValueLabel->setNum(builder.getNumberOfComparator());
    this->ui.latencyValueLabel->setNum(builder.getLatency());
    this->ui.actionSave->setEnabled(true);
    this->ui.buttonSave->setEnabled(true);
    this->saved = false;
    this->generated = true;
    if(showExample) {
        this->picture = builder.paint(w, h, this->lines, this->background, this->exampleFont);
    } else {
        this->picture = builder.paint(w, h, this->lines, this->background);
    }
    this->pixmap = picture_to_pixmap(this->picture);
    this->refresh();
    if(!builder.checkSorted()) {
        const char* msg = (equal > 1) ? "This network fails the stability test." : "This network fails the test.";
        QMessageBox::warning(this, tr("Warning"), tr(msg));
    }
}

bool SortingNetworkMaker::askSaveOrContinue() {
    if (this->generated && ! this->saved)  {
        auto button = QMessageBox::question(
            this, 
            tr("Quit"), 
            tr("Save figure?"),
            QMessageBox::Save | QMessageBox::No | QMessageBox::Cancel
        );
        if (button == QMessageBox::No) {
            return true;
        }
        else if (button == QMessageBox::Save) {
            this->save();
            return true;
        }
        else {
            return false;
        }
    }
    else {
        return true;
    }
}

void SortingNetworkMaker::closeEvent(QCloseEvent *event) {
    if (this->askSaveOrContinue()) {
        event->accept();
    }
    else {
        event->ignore();
    }
}

void SortingNetworkMaker::about() {
    const char *p = "<p>", *q = "</p>";
    QString text;
    text.append(p).append((tr("This is an opensource software."))).append(q);
    text.append(p).append(tr("Author: "));
    text.append("<a href='https://github.com/NIC0NIC0NI'>NIC0NIC0NI</a>").append(q);
    text.append(p).append(tr("License: "));
    text.append("<a href='http://doc.qt.io/qt-5/lgpl.html'>GNU LGPL version 3</a>").append(q);
    text.append(p).append(tr("View source code: "));
    text.append("<a href='https://github.com/NIC0NIC0NI/QT-gui-toys.git'>QT-gui-toys.git</a>").append(q);
    QMessageBox::about(this, tr("About Sorting Network Maker"), text);
}
